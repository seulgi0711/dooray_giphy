(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('sanctuary-show'), require('sanctuary-type-identifiers'), require('denque'), require('sanctuary-type-classes'), require('concurrify')) :
  typeof define === 'function' && define.amd ? define(['sanctuary-show', 'sanctuary-type-identifiers', 'denque', 'sanctuary-type-classes', 'concurrify'], factory) :
  (global.Fluture = factory(global.sanctuaryShow,global.sanctuaryTypeIdentifiers,global.Denque,global.sanctuaryTypeClasses,global.concurrify));
}(this, (function (show,type,Denque,Z,concurrify) { 'use strict';

  show = show && show.hasOwnProperty('default') ? show['default'] : show;
  type = type && type.hasOwnProperty('default') ? type['default'] : type;
  Denque = Denque && Denque.hasOwnProperty('default') ? Denque['default'] : Denque;
  Z = Z && Z.hasOwnProperty('default') ? Z['default'] : Z;
  concurrify = concurrify && concurrify.hasOwnProperty('default') ? concurrify['default'] : concurrify;

  function noop(){}
  function moop(){ return this }
  function padf(sf, s){ return s.replace(/^/gm, sf).replace(sf, '') }
  function showf(f){ return padf('  ', show(f)) }

  function partial1(f, a){
    return function bound1(b, c, d){
      switch(arguments.length){
        case 1: return f(a, b);
        case 2: return f(a, b, c);
        default: return f(a, b, c, d);
      }
    };
  }

  function partial2(f, a, b){
    return function bound2(c, d){
      return arguments.length === 1 ? f(a, b, c) : f(a, b, c, d);
    };
  }

  function partial3(f, a, b, c){
    return function bound3(d){
      return f(a, b, c, d);
    };
  }

  function raise(x){
    throw x;
  }

  function indent(s){
    return '  ' + s;
  }

  var FL = {
    map: 'fantasy-land/map',
    bimap: 'fantasy-land/bimap',
    chain: 'fantasy-land/chain',
    chainRec: 'fantasy-land/chainRec',
    ap: 'fantasy-land/ap',
    of: 'fantasy-land/of',
    zero: 'fantasy-land/zero'
  };

  var ordinal = ['first', 'second', 'third', 'fourth', 'fifth'];

  var namespace = 'fluture';
  var name = 'Future';
  var version = 4;

  var $$type = namespace + '/' + name + '@' + version;

  function error(message){
    return new Error(message);
  }

  function typeError(message){
    return new TypeError(message);
  }

  function invalidArgument(it, at, expected, actual){
    return typeError(
      it + ' expects its ' + ordinal[at] + ' argument to ' + expected + '\n  Actual: ' + show(actual)
    );
  }

  function invalidContext(it, actual){
    return typeError(
      it + ' was invoked outside the context of a Future. You might want to use'
    + ' a dispatcher instead\n  Called on: ' + show(actual)
    );
  }

  function invalidNamespace(m, x){
    return (
      'The Future was not created by ' + namespace + '. '
    + 'Make sure you transform other Futures to ' + namespace + ' Futures. '
    + 'Got ' + (x ? ('a Future from ' + x) : 'an unscoped Future') + '.'
    + '\n  See: https://github.com/fluture-js/Fluture#casting-futures'
    );
  }

  function invalidVersion(m, x){
    return (
      'The Future was created by ' + (x < version ? 'an older' : 'a newer')
    + ' version of ' + namespace + '. '
    + 'This means that one of the sources which creates Futures is outdated. '
    + 'Update this source, or transform its created Futures to be compatible.'
    + '\n  See: https://github.com/fluture-js/Fluture#casting-futures'
    );
  }

  function invalidFuture(it, at, m, s){
    var id = type.parse(type(m));
    var info = id.name === name ? '\n' + (
      id.namespace !== namespace ? invalidNamespace(m, id.namespace)
    : id.version !== version ? invalidVersion(m, id.version)
    : 'Nothing seems wrong. Contact the Fluture maintainers.') : '';
    return typeError(
      it + ' expects ' + (ordinal[at] ? 'its ' + ordinal[at] + ' argument to be a valid Future' : at)
    + '.' + info + '\n  Actual: ' + show(m) + ' :: ' + id.name + (s || '')
    );
  }

  function valueToError(x){
    var name$$1, message;
    try{
      if(x && typeof x.name === 'string' && typeof x.message === 'string'){
        name$$1 = x.name;
        message = x.message;
      }else{
        name$$1 = 'Non-Error';
        message = show(x);
      }
    }catch (_){
      name$$1 = 'Something';
      message = '<The value which was thrown could not be converted to string>';
    }
    var e = error(
      name$$1 + ' occurred while running a computation for a Future:\n\n' +
      message.split('\n').map(indent).join('\n')
    );
    return e;
  }

  function throwInvalidArgument(it, at, expected, actual){
    throw invalidArgument(it, at, expected, actual);
  }

  function throwInvalidContext(it, actual){
    throw invalidContext(it, actual);
  }

  function throwInvalidFuture(it, at, m, s){
    throw invalidFuture(it, at, m, s);
  }

  function isFunction(f){
    return typeof f === 'function';
  }

  function isThenable(m){
    return m instanceof Promise || Boolean(m) && isFunction(m.then);
  }

  function isBoolean(f){
    return typeof f === 'boolean';
  }

  function isNumber(f){
    return typeof f === 'number';
  }

  function isUnsigned(n){
    return (n === Infinity || isNumber(n) && n > 0 && n % 1 === 0);
  }

  function isObject(o){
    return o !== null && typeof o === 'object';
  }

  function isIterator(i){
    return isObject(i) && isFunction(i.next);
  }

  function isArray(x){
    return Array.isArray(x);
  }

  /* eslint no-param-reassign:0 */

  var nil = {head: null};
  nil.tail = nil;

  function cons(head, tail){
    return {head: head, tail: tail};
  }

  /*eslint no-cond-assign:0, no-constant-condition:0 */

  function interpretSequence(seq, rec, rej, res){

    //This is the primary queue of actions. All actions in here will be "cold",
    //meaning they haven't had the chance yet to run concurrent computations.
    var queue = new Denque();

    //These combined variables define our current state.
    // future  = the future we are currently forking
    // action  = the action to be informed when the future settles
    // cancel  = the cancel function of the current future
    // settled = a boolean indicating whether a new tick should start
    // async   = a boolean indicating whether we are awaiting a result asynchronously
    var future, action, cancel = noop, stack = nil, settled, async = true, it;

    //Pushes a new action onto the stack. The stack is used to keep "hot"
    //actions. The last one added is the first one to process, because actions
    //are pushed right-to-left (see warmupActions).
    function pushStack(x){
      stack = cons(x, stack);
    }

    //Takes the leftmost action from the stack and returns it.
    function popStack(){
      var x = stack.head;
      stack = stack.tail;
      return x;
    }

    //This function is called with a future to use in the next tick.
    //Here we "flatten" the actions of another Sequence into our own actions,
    //this is the magic that allows for infinitely stack safe recursion because
    //actions like ChainAction will return a new Sequence.
    //If we settled asynchronously, we call drain() directly to run the next tick.
    function settle(m){
      settled = true;
      future = m;

      if(future._spawn){
        var tail = future._actions;

        while(tail !== nil){
          queue.unshift(tail.head);
          tail = tail.tail;
        }

        future = future._spawn;
      }

      if(async) drain();
    }

    //This function serves as a rejection handler for our current future.
    //It will tell the current action that the future rejected, and it will
    //settle the current tick with the action's answer to that.
    function rejected(x){
      settle(action.rejected(x));
    }

    //This function serves as a resolution handler for our current future.
    //It will tell the current action that the future resolved, and it will
    //settle the current tick with the action's answer to that.
    function resolved(x){
      settle(action.resolved(x));
    }

    //This function is passed into actions when they are "warmed up".
    //If the action decides that it has its result, without the need to await
    //anything else, then it can call this function to force "early termination".
    //When early termination occurs, all actions which were queued prior to the
    //terminator will be skipped. If they were already hot, they will also receive
    //a cancel signal so they can cancel their own concurrent computations, as
    //their results are no longer needed.
    function early(m, terminator){
      cancel();
      queue.clear();

      if(async && action !== terminator){
        action.cancel();
        while((it = popStack()) && it !== terminator) it.cancel();
      }

      settle(m);
    }

    //This will cancel the current Future, the current action, and all queued hot actions.
    function Sequence$cancel(){
      cancel();
      action && action.cancel();
      while(it = popStack()) it.cancel();
    }

    //This function is called when an exception is caught.
    function exception(e){
      Sequence$cancel();
      rec(e);
    }

    //This function serves to kickstart concurrent computations.
    //Takes all actions from the cold queue *back-to-front*, and calls run() on
    //each of them, passing them the "early" function. If any of them settles (by
    //calling early()), we abort. After warming up all actions in the cold queue,
    //we warm up the current action as well.
    function warmupActions(){
      while(it = queue.pop()){
        it = it.run(early);
        if(settled) return;
        pushStack(it);
      }
      action = action.run(early);
    }

    //This function represents our main execution loop.
    //When we refer to a "tick", we mean the execution of the body inside the
    //primary while-loop of this function.
    //Every tick follows the following algorithm:
    // 1. We try to take an action from the cold queue, if we fail, go to step 2.
    //      1a. We fork the future.
    //      1b. We warmupActions() if the we haven't settled yet.
    // 2. We try to take an action from the hot queue, if we fail, go to step 3.
    //      2a. We fork the Future, if settles, we continue to the next tick.
    // 3. If we couldn't take actions from either queues, we fork the Future into
    //    the user provided continuations. This is the end of the interpretation.
    // 4. If we did take an action from one of queues, but none of the steps
    //    caused a settle(), it means we are asynchronously waiting for something
    //    to settle and start the next tick, so we return from the function.
    function drain(){
      async = false;

      while(true){
        settled = false;
        if(action = queue.shift()){
          cancel = future._interpret(exception, rejected, resolved);
          if(!settled) warmupActions();
        }else if(action = popStack()){
          cancel = future._interpret(exception, rejected, resolved);
        }else break;
        if(settled) continue;
        async = true;
        return;
      }

      cancel = future._interpret(exception, rej, res);
    }

    //Start the execution loop.
    settle(seq);

    //Return the cancellation function.
    return Sequence$cancel;

  }

  function Future$value$rej(x){
    raise(error(
      'Future#value was called on a rejected Future\n' +
      '  Actual: Future.reject(' + show(x) + ')'
    ));
  }

  function Future$onCrash(x){
    raise(valueToError(x));
  }

  function Future(computation){
    if(!isFunction(computation)) throwInvalidArgument('Future', 0, 'be a Function', computation);
    return new Computation(computation);
  }

  function isFuture(x){
    return x instanceof Future || type(x) === $$type;
  }

  Future['@@type'] = $$type;

  Future.prototype['@@show'] = function Future$show(){
    return this.toString();
  };

  Future.prototype[FL.ap] = function Future$FL$ap(other){
    return other._ap(this);
  };

  Future.prototype[FL.map] = function Future$FL$map(mapper){
    return this._map(mapper);
  };

  Future.prototype[FL.bimap] = function Future$FL$bimap(lmapper, rmapper){
    return this._bimap(lmapper, rmapper);
  };

  Future.prototype[FL.chain] = function Future$FL$chain(mapper){
    return this._chain(mapper);
  };

  Future.prototype.ap = function Future$ap(other){
    if(!isFuture(this)) throwInvalidContext('Future#ap', this);
    if(!isFuture(other)) throwInvalidFuture('Future#ap', 0, other);
    return this._ap(other);
  };

  Future.prototype.map = function Future$map(mapper){
    if(!isFuture(this)) throwInvalidContext('Future#map', this);
    if(!isFunction(mapper)) throwInvalidArgument('Future#map', 0, 'to be a Function', mapper);
    return this._map(mapper);
  };

  Future.prototype.bimap = function Future$bimap(lmapper, rmapper){
    if(!isFuture(this)) throwInvalidContext('Future#bimap', this);
    if(!isFunction(lmapper)) throwInvalidArgument('Future#bimap', 0, 'to be a Function', lmapper);
    if(!isFunction(rmapper)) throwInvalidArgument('Future#bimap', 1, 'to be a Function', rmapper);
    return this._bimap(lmapper, rmapper);
  };

  Future.prototype.chain = function Future$chain(mapper){
    if(!isFuture(this)) throwInvalidContext('Future#chain', this);
    if(!isFunction(mapper)) throwInvalidArgument('Future#chain', 0, 'to be a Function', mapper);
    return this._chain(mapper);
  };

  Future.prototype.mapRej = function Future$mapRej(mapper){
    if(!isFuture(this)) throwInvalidContext('Future#mapRej', this);
    if(!isFunction(mapper)) throwInvalidArgument('Future#mapRej', 0, 'to be a Function', mapper);
    return this._mapRej(mapper);
  };

  Future.prototype.chainRej = function Future$chainRej(mapper){
    if(!isFuture(this)) throwInvalidContext('Future#chainRej', this);
    if(!isFunction(mapper)) throwInvalidArgument('Future#chainRej', 0, 'to be a Function', mapper);
    return this._chainRej(mapper);
  };

  Future.prototype.race = function Future$race(other){
    if(!isFuture(this)) throwInvalidContext('Future#race', this);
    if(!isFuture(other)) throwInvalidFuture('Future#race', 0, other);
    return this._race(other);
  };

  Future.prototype.both = function Future$both(other){
    if(!isFuture(this)) throwInvalidContext('Future#both', this);
    if(!isFuture(other)) throwInvalidFuture('Future#both', 0, other);
    return this._both(other);
  };

  Future.prototype.and = function Future$and(other){
    if(!isFuture(this)) throwInvalidContext('Future#and', this);
    if(!isFuture(other)) throwInvalidFuture('Future#and', 0, other);
    return this._and(other);
  };

  Future.prototype.or = function Future$or(other){
    if(!isFuture(this)) throwInvalidContext('Future#or', this);
    if(!isFuture(other)) throwInvalidFuture('Future#or', 0, other);
    return this._or(other);
  };

  Future.prototype.swap = function Future$swap(){
    if(!isFuture(this)) throwInvalidContext('Future#ap', this);
    return this._swap();
  };

  Future.prototype.fold = function Future$fold(lmapper, rmapper){
    if(!isFuture(this)) throwInvalidContext('Future#ap', this);
    if(!isFunction(lmapper)) throwInvalidArgument('Future#fold', 0, 'to be a Function', lmapper);
    if(!isFunction(rmapper)) throwInvalidArgument('Future#fold', 1, 'to be a Function', rmapper);
    return this._fold(lmapper, rmapper);
  };

  Future.prototype.finally = function Future$finally(other){
    if(!isFuture(this)) throwInvalidContext('Future#finally', this);
    if(!isFuture(other)) throwInvalidFuture('Future#finally', 0, other);
    return this._finally(other);
  };

  Future.prototype.lastly = function Future$lastly(other){
    if(!isFuture(this)) throwInvalidContext('Future#lastly', this);
    if(!isFuture(other)) throwInvalidFuture('Future#lastly', 0, other);
    return this._finally(other);
  };

  Future.prototype.fork = function Future$fork(rej, res){
    if(!isFuture(this)) throwInvalidContext('Future#fork', this);
    if(!isFunction(rej)) throwInvalidArgument('Future#fork', 0, 'to be a Function', rej);
    if(!isFunction(res)) throwInvalidArgument('Future#fork', 1, 'to be a Function', res);
    return this._interpret(Future$onCrash, rej, res);
  };

  Future.prototype.forkCatch = function Future$forkCatch(rec, rej, res){
    if(!isFuture(this)) throwInvalidContext('Future#fork', this);
    if(!isFunction(rec)) throwInvalidArgument('Future#fork', 0, 'to be a Function', rec);
    if(!isFunction(rej)) throwInvalidArgument('Future#fork', 1, 'to be a Function', rej);
    if(!isFunction(res)) throwInvalidArgument('Future#fork', 2, 'to be a Function', res);
    return this._interpret(function Future$forkCatch$recover(x){ rec(valueToError(x)); }, rej, res);
  };

  Future.prototype.value = function Future$value(res){
    if(!isFuture(this)) throwInvalidContext('Future#value', this);
    if(!isFunction(res)) throwInvalidArgument('Future#value', 0, 'to be a Function', res);
    return this._interpret(Future$onCrash, Future$value$rej, res);
  };

  Future.prototype.done = function Future$done(callback){
    if(!isFuture(this)) throwInvalidContext('Future#done', this);
    if(!isFunction(callback)) throwInvalidArgument('Future#done', 0, 'to be a Function', callback);
    return this._interpret(Future$onCrash,
                           function Future$done$rej(x){ callback(x); },
                           function Future$done$res(x){ callback(null, x); });
  };

  Future.prototype.promise = function Future$promise(){
    var _this = this;
    return new Promise(function Future$promise$computation(res, rej){
      _this._interpret(Future$onCrash, rej, res);
    });
  };

  Future.prototype.extractLeft = function Future$extractLeft(){
    return [];
  };

  Future.prototype.extractRight = function Future$extractRight(){
    return [];
  };

  Future.prototype._transform = function Future$transform(action){
    return new Sequence(this, cons(action, nil));
  };

  Future.prototype._ap = function Future$ap(other){
    return this._transform(new ApAction(other));
  };

  Future.prototype._parallelAp = function Future$pap(other){
    return this._transform(new ParallelApAction(other));
  };

  Future.prototype._map = function Future$map(mapper){
    return this._transform(new MapAction(mapper));
  };

  Future.prototype._bimap = function Future$bimap(lmapper, rmapper){
    return this._transform(new BimapAction(lmapper, rmapper));
  };

  Future.prototype._chain = function Future$chain(mapper){
    return this._transform(new ChainAction(mapper));
  };

  Future.prototype._mapRej = function Future$mapRej(mapper){
    return this._transform(new MapRejAction(mapper));
  };

  Future.prototype._chainRej = function Future$chainRej(mapper){
    return this._transform(new ChainRejAction(mapper));
  };

  Future.prototype._race = function Future$race(other){
    return isNever(other) ? this : this._transform(new RaceAction(other));
  };

  Future.prototype._both = function Future$both(other){
    return this._transform(new BothAction(other));
  };

  Future.prototype._and = function Future$and(other){
    return this._transform(new AndAction(other));
  };

  Future.prototype._or = function Future$or(other){
    return this._transform(new OrAction(other));
  };

  Future.prototype._swap = function Future$swap(){
    return this._transform(new SwapAction);
  };

  Future.prototype._fold = function Future$fold(lmapper, rmapper){
    return this._transform(new FoldAction(lmapper, rmapper));
  };

  Future.prototype._finally = function Future$finally(other){
    return this._transform(new FinallyAction(other));
  };

  function Computation(computation){
    this._computation = computation;
  }

  Computation.prototype = Object.create(Future.prototype);

  Computation.prototype._interpret = function Computation$interpret(rec, rej, res){
    var open = false, cancel = noop, cont = function(){ open = true; };
    try{
      cancel = this._computation(function Computation$rej(x){
        cont = function Computation$rej$cont(){
          open = false;
          rej(x);
        };
        if(open){
          cont();
        }
      }, function Computation$res(x){
        cont = function Computation$res$cont(){
          open = false;
          res(x);
        };
        if(open){
          cont();
        }
      }) || noop;
    }catch(e){
      open = false;
      rec(e);
      return noop;
    }
    if(!(isFunction(cancel) && cancel.length === 0)){
      rec(typeError(
        'The computation was expected to return a nullary function or void\n' +
        '  Actual: ' + show(cancel)
      ));
    }
    cont();
    return function Computation$cancel(){
      if(open){
        open = false;
        cancel && cancel();
      }
    };
  };

  Computation.prototype.toString = function Computation$toString(){
    return 'Future(' + showf(this._computation) + ')';
  };

  function Crashed(error$$1){
    this._error = error$$1;
  }

  Crashed.prototype = Object.create(Future.prototype);

  Crashed.prototype._ap = moop;
  Crashed.prototype._parallelAp = moop;
  Crashed.prototype._map = moop;
  Crashed.prototype._bimap = moop;
  Crashed.prototype._chain = moop;
  Crashed.prototype._mapRej = moop;
  Crashed.prototype._chainRej = moop;
  Crashed.prototype._both = moop;
  Crashed.prototype._or = moop;
  Crashed.prototype._swap = moop;
  Crashed.prototype._fold = moop;
  Crashed.prototype._finally = moop;
  Crashed.prototype._race = moop;

  Crashed.prototype._interpret = function Crashed$interpret(rec){
    rec(this._error);
    return noop;
  };

  function Rejected(value){
    this._value = value;
  }

  Rejected.prototype = Object.create(Future.prototype);

  Rejected.prototype._ap = moop;
  Rejected.prototype._parallelAp = moop;
  Rejected.prototype._map = moop;
  Rejected.prototype._chain = moop;
  Rejected.prototype._race = moop;
  Rejected.prototype._both = moop;
  Rejected.prototype._and = moop;

  Rejected.prototype._or = function Rejected$or(other){
    return other;
  };

  Rejected.prototype._finally = function Rejected$finally(other){
    return other._and(this);
  };

  Rejected.prototype._swap = function Rejected$swap(){
    return new Resolved(this._value);
  };

  Rejected.prototype._interpret = function Rejected$interpret(rec, rej){
    rej(this._value);
    return noop;
  };

  Rejected.prototype.extractLeft = function Rejected$extractLeft(){
    return [this._value];
  };

  Rejected.prototype.toString = function Rejected$toString(){
    return 'Future.reject(' + show(this._value) + ')';
  };

  function reject(x){
    return new Rejected(x);
  }

  function Resolved(value){
    this._value = value;
  }

  Resolved.prototype = Object.create(Future.prototype);

  Resolved.prototype._race = moop;
  Resolved.prototype._mapRej = moop;
  Resolved.prototype._or = moop;

  Resolved.prototype._and = function Resolved$and(other){
    return other;
  };

  Resolved.prototype._both = function Resolved$both(other){
    var left = this._value;
    return other._map(function Resolved$both$mapper(right){
      return [left, right];
    });
  };

  Resolved.prototype._swap = function Resolved$swap(){
    return new Rejected(this._value);
  };

  Resolved.prototype._finally = function Resolved$finally(other){
    var value = this._value;
    return other._map(function Resolved$finally$mapper(){
      return value;
    });
  };

  Resolved.prototype._interpret = function Resolved$interpret(rec, rej, res){
    res(this._value);
    return noop;
  };

  Resolved.prototype.extractRight = function Resolved$extractRight(){
    return [this._value];
  };

  Resolved.prototype.toString = function Resolved$toString(){
    return 'Future.of(' + show(this._value) + ')';
  };

  function of(x){
    return new Resolved(x);
  }

  function Never(){
    this._isNever = true;
  }

  Never.prototype = Object.create(Future.prototype);

  Never.prototype._ap = moop;
  Never.prototype._parallelAp = moop;
  Never.prototype._map = moop;
  Never.prototype._bimap = moop;
  Never.prototype._chain = moop;
  Never.prototype._mapRej = moop;
  Never.prototype._chainRej = moop;
  Never.prototype._both = moop;
  Never.prototype._or = moop;
  Never.prototype._swap = moop;
  Never.prototype._fold = moop;
  Never.prototype._finally = moop;

  Never.prototype._race = function Never$race(other){
    return other;
  };

  Never.prototype._interpret = function Never$interpret(){
    return noop;
  };

  Never.prototype.toString = function Never$toString(){
    return 'Future.never';
  };

  var never = new Never();

  function isNever(x){
    return isFuture(x) && x._isNever === true;
  }

  function Eager(future){
    var _this = this;
    _this.rec = noop;
    _this.rej = noop;
    _this.res = noop;
    _this.crashed = false;
    _this.rejected = false;
    _this.resolved = false;
    _this.value = null;
    _this.cancel = future._interpret(function Eager$crash(x){
      _this.value = x;
      _this.crashed = true;
      _this.cancel = noop;
      _this.rec(x);
    }, function Eager$reject(x){
      _this.value = x;
      _this.rejected = true;
      _this.cancel = noop;
      _this.rej(x);
    }, function Eager$resolve(x){
      _this.value = x;
      _this.resolved = true;
      _this.cancel = noop;
      _this.res(x);
    });
  }

  Eager.prototype = Object.create(Future.prototype);

  Eager.prototype._interpret = function Eager$interpret(rec, rej, res){
    if(this.crashed) rec(this.value);
    else if(this.rejected) rej(this.value);
    else if(this.resolved) res(this.value);
    else{
      this.rec = rec;
      this.rej = rej;
      this.res = res;
    }
    return this.cancel;
  };

  var Action = {
    rejected: function Action$rejected(x){ this.cancel(); return new Rejected(x) },
    resolved: function Action$resolved(x){ this.cancel(); return new Resolved(x) },
    run: function Action$run(){ return this },
    cancel: function Action$cancel(){}
  };

  function ApAction(other){ this.other = other; }
  ApAction.prototype = Object.create(Action);

  ApAction.prototype.resolved = function ApAction$resolved(f){
    return isFunction(f) ?
           this.other._map(function ApAction$resolved$mapper(x){ return f(x) }) :
           new Crashed(typeError(
             'Future#ap expects its first argument to be a Future of a Function'
             + '\n  Actual: Future.of(' + show(f) + ')'
           ));
  };

  ApAction.prototype.toString = function ApAction$toString(){
    return 'ap(' + this.other.toString() + ')';
  };

  function MapAction(mapper){ this.mapper = mapper; }
  MapAction.prototype = Object.create(Action);

  MapAction.prototype.resolved = function MapAction$resolved(x){
    var m;
    try{ m = new Resolved(this.mapper(x)); }catch(e){ m = new Crashed(e); }
    return m;
  };

  MapAction.prototype.toString = function MapAction$toString(){
    return 'map(' + showf(this.mapper) + ')';
  };

  function BimapAction(lmapper, rmapper){ this.lmapper = lmapper; this.rmapper = rmapper; }
  BimapAction.prototype = Object.create(Action);

  BimapAction.prototype.rejected = function BimapAction$rejected(x){
    var m;
    try{ m = new Rejected(this.lmapper(x)); }catch(e){ m = new Crashed(e); }
    return m;
  };

  BimapAction.prototype.resolved = function BimapAction$resolved(x){
    var m;
    try{ m = new Resolved(this.rmapper(x)); }catch(e){ m = new Crashed(e); }
    return m;
  };

  BimapAction.prototype.toString = function BimapAction$toString(){
    return 'bimap(' + showf(this.lmapper) + ', ' + showf(this.rmapper) + ')';
  };

  function ChainAction(mapper){ this.mapper = mapper; }
  ChainAction.prototype = Object.create(Action);

  ChainAction.prototype.resolved = function ChainAction$resolved(x){
    var m;
    try{ m = this.mapper(x); }catch(e){ return new Crashed(e) }
    return isFuture(m) ? m : new Crashed(invalidFuture(
      'Future#chain',
      'the function it\'s given to return a Future',
      m,
      '\n  From calling: ' + showf(this.mapper) + '\n  With: ' + show(x)
    ));
  };

  ChainAction.prototype.toString = function ChainAction$toString(){
    return 'chain(' + showf(this.mapper) + ')';
  };

  function MapRejAction(mapper){ this.mapper = mapper; }
  MapRejAction.prototype = Object.create(Action);

  MapRejAction.prototype.rejected = function MapRejAction$rejected(x){
    var m;
    try{ m = new Rejected(this.mapper(x)); }catch(e){ m = new Crashed(e); }
    return m;
  };

  MapRejAction.prototype.toString = function MapRejAction$toString(){
    return 'mapRej(' + showf(this.mapper) + ')';
  };

  function ChainRejAction(mapper){ this.mapper = mapper; }
  ChainRejAction.prototype = Object.create(Action);

  ChainRejAction.prototype.rejected = function ChainRejAction$rejected(x){
    var m;
    try{ m = this.mapper(x); }catch(e){ return new Crashed(e) }
    return isFuture(m) ? m : new Crashed(invalidFuture(
      'Future#chainRej',
      'the function it\'s given to return a Future',
      m,
      '\n  From calling: ' + showf(this.mapper) + '\n  With: ' + show(x)
    ));
  };

  ChainRejAction.prototype.toString = function ChainRejAction$toString(){
    return 'chainRej(' + showf(this.mapper) + ')';
  };

  function SwapAction(){}
  SwapAction.prototype = Object.create(Action);

  SwapAction.prototype.rejected = function SwapAction$rejected(x){
    return new Resolved(x);
  };

  SwapAction.prototype.resolved = function SwapAction$resolved(x){
    return new Rejected(x);
  };

  SwapAction.prototype.toString = function SwapAction$toString(){
    return 'swap()';
  };

  function FoldAction(lmapper, rmapper){ this.lmapper = lmapper; this.rmapper = rmapper; }
  FoldAction.prototype = Object.create(Action);

  FoldAction.prototype.rejected = function FoldAction$rejected(x){
    var m;
    try{ m = new Resolved(this.lmapper(x)); }catch(e){ m = new Crashed(e); }
    return m;
  };

  FoldAction.prototype.resolved = function FoldAction$resolved(x){
    var m;
    try{ m = new Resolved(this.rmapper(x)); }catch(e){ m = new Crashed(e); }
    return m;
  };

  FoldAction.prototype.toString = function FoldAction$toString(){
    return 'fold(' + showf(this.lmapper) + ', ' + showf(this.rmapper) + ')';
  };

  function FinallyAction(other){ this.other = other; }
  FinallyAction.prototype = Object.create(Action);

  FinallyAction.prototype.rejected = function FinallyAction$rejected(x){
    return this.other._and(new Rejected(x));
  };

  FinallyAction.prototype.resolved = function FinallyAction$resolved(x){
    return this.other._map(function FoldAction$resolved$mapper(){ return x });
  };

  FinallyAction.prototype.cancel = function FinallyAction$cancel(){
    this.other._interpret(noop, noop, noop)();
  };

  FinallyAction.prototype.toString = function FinallyAction$toString(){
    return 'finally(' + this.other.toString() + ')';
  };

  function AndAction(other){ this.other = other; }
  AndAction.prototype = Object.create(Action);

  AndAction.prototype.resolved = function AndAction$resolved(){
    return this.other;
  };

  AndAction.prototype.toString = function AndAction$toString(){
    return 'and(' + this.other.toString() + ')';
  };

  function OrAction(other){ this.other = other; }
  OrAction.prototype = Object.create(Action);

  OrAction.prototype.rejected = function OrAction$rejected(){
    return this.other;
  };

  OrAction.prototype.toString = function OrAction$toString(){
    return 'or(' + this.other.toString() + ')';
  };

  function ParallelApAction(other){ this.other = other; }
  ParallelApAction.prototype = Object.create(ApAction.prototype);

  ParallelApAction.prototype.run = function ParallelApAction$run(early){
    return new ParallelApActionState(early, this.other);
  };

  ParallelApAction.prototype.toString = function ParallelApAction$toString(){
    return '_parallelAp(' + this.other.toString() + ')';
  };

  function RaceAction(other){ this.other = other; }
  RaceAction.prototype = Object.create(Action);

  RaceAction.prototype.run = function RaceAction$run(early){
    return new RaceActionState(early, this.other);
  };

  RaceAction.prototype.toString = function RaceAction$toString(){
    return 'race(' + this.other.toString() + ')';
  };

  function BothAction(other){ this.other = other; }
  BothAction.prototype = Object.create(Action);

  BothAction.prototype.resolved = function BothAction$resolved(x){
    return this.other._map(function BothAction$resolved$mapper(y){ return [x, y] });
  };

  BothAction.prototype.run = function BothAction$run(early){
    return new BothActionState(early, this.other);
  };

  BothAction.prototype.toString = function BothAction$toString(){
    return 'both(' + this.other.toString() + ')';
  };

  function ParallelApActionState(early, other){
    var _this = this;
    _this.other = new Eager(other);
    _this.cancel = _this.other._interpret(
      function ParallelApActionState$rec(x){ early(new Crashed(x), _this); },
      function ParallelApActionState$rej(x){ early(new Rejected(x), _this); },
      noop
    );
  }

  ParallelApActionState.prototype = Object.create(ParallelApAction.prototype);

  function RaceActionState(early, other){
    var _this = this;
    _this.other = new Eager(other);
    _this.cancel = _this.other._interpret(
      function RaceActionState$rec(x){ early(new Crashed(x), _this); },
      function RaceActionState$rej(x){ early(new Rejected(x), _this); },
      function RaceActionState$res(x){ early(new Resolved(x), _this); }
    );
  }

  RaceActionState.prototype = Object.create(RaceAction.prototype);

  function BothActionState(early, other){
    var _this = this;
    _this.other = new Eager(other);
    _this.cancel = _this.other._interpret(
      function BothActionState$rec(x){ early(new Crashed(x), _this); },
      function BothActionState$rej(x){ early(new Rejected(x), _this); },
      noop
    );
  }

  BothActionState.prototype = Object.create(BothAction.prototype);

  function Sequence(spawn, actions){
    this._spawn = spawn;
    this._actions = actions;
  }

  Sequence.prototype = Object.create(Future.prototype);

  Sequence.prototype._transform = function Sequence$_transform(action){
    return new Sequence(this._spawn, cons(action, this._actions));
  };

  Sequence.prototype._interpret = function Sequence$interpret(rec, rej, res){
    return interpretSequence(this, rec, rej, res);
  };

  Sequence.prototype.toString = function Sequence$toString(){
    var str = '', tail = this._actions;

    while(tail !== nil){
      str = '.' + tail.head.toString() + str;
      tail = tail.tail;
    }

    return this._spawn.toString() + str;
  };

  function Next(x){
    return {done: false, value: x};
  }

  function Done(x){
    return {done: true, value: x};
  }

  function isIteration(x){
    return isObject(x) && isBoolean(x.done);
  }

  var Undetermined = 0;
  var Synchronous = 1;
  var Asynchronous = 2;

  function ChainRec(step, init){
    this._step = step;
    this._init = init;
  }

  ChainRec.prototype = Object.create(Future.prototype);

  ChainRec.prototype._interpret = function ChainRec$interpret(rec, rej, res){

    var _step = this._step;
    var _init = this._init;
    var timing = Undetermined, cancel = noop, state = Next(_init);

    function resolved(it){
      state = it;
      timing = timing === Undetermined ? Synchronous : drain();
    }

    function drain(){
      while(!state.done){
        timing = Undetermined;

        try{
          var m = _step(Next, Done, state.value);
        }catch(e){
          rec(e);
          return;
        }

        cancel = m._interpret(rec, rej, resolved);

        if(timing !== Synchronous){
          timing = Asynchronous;
          return;
        }
      }

      res(state.value);
    }

    drain();

    return function Future$chainRec$cancel(){ cancel(); };

  };

  ChainRec.prototype.toString = function ChainRec$toString(){
    return 'Future.chainRec(' + showf(this._step) + ', ' + show(this._init) + ')';
  };

  function chainRec(step, init){
    return new ChainRec(step, init);
  }

  function ap$mval(mval, mfunc){
    if(!Z.Apply.test(mfunc)) throwInvalidArgument('Future.ap', 1, 'be an Apply', mfunc);
    return Z.ap(mval, mfunc);
  }

  function ap(mval, mfunc){
    if(!Z.Apply.test(mval)) throwInvalidArgument('Future.ap', 0, 'be an Apply', mval);
    if(arguments.length === 1) return partial1(ap$mval, mval);
    return ap$mval(mval, mfunc);
  }

  function alt$left(left, right){
    if(!Z.Alt.test(right)) throwInvalidArgument('alt', 1, 'be an Alt', right);
    return Z.alt(left, right);
  }

  function alt(left, right){
    if(!Z.Alt.test(left)) throwInvalidArgument('alt', 0, 'be an Alt', left);
    if(arguments.length === 1) return partial1(alt$left, left);
    return alt$left(left, right);
  }

  function map$mapper(mapper, m){
    if(!Z.Functor.test(m)) throwInvalidArgument('Future.map', 1, 'be a Functor', m);
    return Z.map(mapper, m);
  }

  function map(mapper, m){
    if(!isFunction(mapper)) throwInvalidArgument('Future.map', 0, 'be a Function', mapper);
    if(arguments.length === 1) return partial1(map$mapper, mapper);
    return map$mapper(mapper, m);
  }

  function bimap$lmapper$rmapper(lmapper, rmapper, m){
    if(!Z.Bifunctor.test(m)) throwInvalidArgument('Future.bimap', 2, 'be a Bifunctor', m);
    return Z.bimap(lmapper, rmapper, m);
  }

  function bimap$lmapper(lmapper, rmapper, m){
    if(!isFunction(rmapper)) throwInvalidArgument('Future.bimap', 1, 'be a Function', rmapper);
    if(arguments.length === 2) return partial2(bimap$lmapper$rmapper, lmapper, rmapper);
    return bimap$lmapper$rmapper(lmapper, rmapper, m);
  }

  function bimap(lmapper, rmapper, m){
    if(!isFunction(lmapper)) throwInvalidArgument('Future.bimap', 0, 'be a Function', lmapper);
    if(arguments.length === 1) return partial1(bimap$lmapper, lmapper);
    if(arguments.length === 2) return bimap$lmapper(lmapper, rmapper);
    return bimap$lmapper(lmapper, rmapper, m);
  }

  function chain$chainer(chainer, m){
    if(!Z.Chain.test(m)) throwInvalidArgument('Future.chain', 1, 'be a Chain', m);
    return Z.chain(chainer, m);
  }

  function chain(chainer, m){
    if(!isFunction(chainer)) throwInvalidArgument('Future.chain', 0, 'be a Function', chainer);
    if(arguments.length === 1) return partial1(chain$chainer, chainer);
    return chain$chainer(chainer, m);
  }

  function mapRej$mapper(mapper, m){
    if(!isFuture(m)) throwInvalidFuture('Future.mapRej', 1, m);
    return m.mapRej(mapper);
  }

  function mapRej(mapper, m){
    if(!isFunction(mapper)) throwInvalidArgument('Future.mapRej', 0, 'be a Function', mapper);
    if(arguments.length === 1) return partial1(mapRej$mapper, mapper);
    return mapRej$mapper(mapper, m);
  }

  function chainRej$chainer(chainer, m){
    if(!isFuture(m)) throwInvalidFuture('Future.chainRej', 1, m);
    return m.chainRej(chainer);
  }

  function chainRej(chainer, m){
    if(!isFunction(chainer)) throwInvalidArgument('Future.chainRej', 0, 'be a Function', chainer);
    if(arguments.length === 1) return partial1(chainRej$chainer, chainer);
    return chainRej$chainer(chainer, m);
  }

  function lastly$right(right, left){
    if(!isFuture(left)) throwInvalidFuture('Future.finally', 1, left);
    return left.finally(right);
  }

  function lastly(right, left){
    if(!isFuture(right)) throwInvalidFuture('Future.finally', 0, right);
    if(arguments.length === 1) return partial1(lastly$right, right);
    return lastly$right(right, left);
  }

  function and$left(left, right){
    if(!isFuture(right)) throwInvalidFuture('Future.and', 1, right);
    return left.and(right);
  }

  function and(left, right){
    if(!isFuture(left)) throwInvalidFuture('Future.and', 0, left);
    if(arguments.length === 1) return partial1(and$left, left);
    return and$left(left, right);
  }

  function both$left(left, right){
    if(!isFuture(right)) throwInvalidFuture('Future.both', 1, right);
    return left.both(right);
  }

  function both(left, right){
    if(!isFuture(left)) throwInvalidFuture('Future.both', 0, left);
    if(arguments.length === 1) return partial1(both$left, left);
    return both$left(left, right);
  }

  function or$left(left, right){
    if(!isFuture(right)) throwInvalidFuture('Future.or', 1, right);
    return left.or(right);
  }

  function or(left, right){
    if(!isFuture(left)) throwInvalidFuture('Future.or', 0, left);
    if(arguments.length === 1) return partial1(or$left, left);
    return or$left(left, right);
  }

  function race$right(right, left){
    if(!isFuture(left)) throwInvalidFuture('Future.race', 1, left);
    return left.race(right);
  }

  function race(right, left){
    if(!isFuture(right)) throwInvalidFuture('Future.race', 0, right);
    if(arguments.length === 1) return partial1(race$right, right);
    return race$right(right, left);
  }

  function swap(m){
    if(!isFuture(m)) throwInvalidFuture('Future.swap', 0, m);
    return m.swap();
  }

  function fold$f$g(f, g, m){
    if(!isFuture(m)) throwInvalidFuture('Future.fold', 2, m);
    return m.fold(f, g);
  }

  function fold$f(f, g, m){
    if(!isFunction(g)) throwInvalidArgument('Future.fold', 1, 'be a function', g);
    if(arguments.length === 2) return partial2(fold$f$g, f, g);
    return fold$f$g(f, g, m);
  }

  function fold(f, g, m){
    if(!isFunction(f)) throwInvalidArgument('Future.fold', 0, 'be a function', f);
    if(arguments.length === 1) return partial1(fold$f, f);
    if(arguments.length === 2) return fold$f(f, g);
    return fold$f(f, g, m);
  }

  function done$callback(callback, m){
    if(!isFuture(m)) throwInvalidFuture('Future.done', 1, m);
    return m.done(callback);
  }

  function done(callback, m){
    if(!isFunction(callback)) throwInvalidArgument('Future.done', 0, 'be a Function', callback);
    if(arguments.length === 1) return partial1(done$callback, callback);
    return done$callback(callback, m);
  }

  function fork$f$g(f, g, m){
    if(!isFuture(m)) throwInvalidFuture('Future.fork', 2, m);
    return m._interpret(raise, f, g);
  }

  function fork$f(f, g, m){
    if(!isFunction(g)) throwInvalidArgument('Future.fork', 1, 'be a function', g);
    if(arguments.length === 2) return partial2(fork$f$g, f, g);
    return fork$f$g(f, g, m);
  }

  function fork(f, g, m){
    if(!isFunction(f)) throwInvalidArgument('Future.fork', 0, 'be a function', f);
    if(arguments.length === 1) return partial1(fork$f, f);
    if(arguments.length === 2) return fork$f(f, g);
    return fork$f(f, g, m);
  }

  function forkCatch(f, g, h, m){
    if(!isFunction(f)) throwInvalidArgument('Future.forkCatch', 0, 'be a function', f);
    if(arguments.length === 1) return partial1(forkCatch, f);
    if(!isFunction(g)) throwInvalidArgument('Future.forkCatch', 1, 'be a function', g);
    if(arguments.length === 2) return partial2(forkCatch, f, g);
    if(!isFunction(h)) throwInvalidArgument('Future.forkCatch', 2, 'be a function', h);
    if(arguments.length === 3) return partial3(forkCatch, f, g, h);
    if(!isFuture(m)) throwInvalidFuture('Future.forkCatch', 3, m);
    return m._interpret(function forkCatch$recover(x){ f(valueToError(x)); }, g, h);
  }

  function promise(m){
    if(!isFuture(m)) throwInvalidFuture('Future.promise', 0, m);
    return m.promise();
  }

  function value$cont(cont, m){
    if(!isFuture(m)) throwInvalidFuture('Future.value', 1, m);
    return m.value(cont);
  }

  function value(cont, m){
    if(!isFunction(cont)) throwInvalidArgument('Future.value', 0, 'be a Function', cont);
    if(arguments.length === 1) return partial1(value$cont, cont);
    return value$cont(cont, m);
  }

  function extractLeft(m){
    if(!isFuture(m)) throwInvalidFuture('Future.extractLeft', 0, m);
    return m.extractLeft();
  }

  function extractRight(m){
    if(!isFuture(m)) throwInvalidFuture('Future.extractRight', 0, m);
    return m.extractRight();
  }

  function After$race(other){
    return typeof other._time === 'number'
         ? other._time < this._time ? other : this
         : Future.prototype._race.call(this, other);
  }

  function After(time, value){
    this._time = time;
    this._value = value;
  }

  After.prototype = Object.create(Future.prototype);

  After.prototype._race = After$race;

  After.prototype._swap = function After$swap(){
    return new RejectAfter(this._time, this._value);
  };

  After.prototype._interpret = function After$interpret(rec, rej, res){
    var id = setTimeout(res, this._time, this._value);
    return function After$cancel(){ clearTimeout(id); };
  };

  After.prototype.extractRight = function After$extractRight(){
    return [this._value];
  };

  After.prototype.toString = function After$toString(){
    return 'Future.after(' + show(this._time) + ', ' + show(this._value) + ')';
  };

  function RejectAfter(time, value){
    this._time = time;
    this._value = value;
  }

  RejectAfter.prototype = Object.create(Future.prototype);

  RejectAfter.prototype._race = After$race;

  RejectAfter.prototype._swap = function RejectAfter$swap(){
    return new After(this._time, this._value);
  };

  RejectAfter.prototype._interpret = function RejectAfter$interpret(rec, rej){
    var id = setTimeout(rej, this._time, this._value);
    return function RejectAfter$cancel(){ clearTimeout(id); };
  };

  RejectAfter.prototype.extractLeft = function RejectAfter$extractLeft(){
    return [this._value];
  };

  RejectAfter.prototype.toString = function RejectAfter$toString(){
    return 'Future.rejectAfter(' + show(this._time) + ', ' + show(this._value) + ')';
  };

  function after$time(time, value){
    return time === Infinity ? never : new After(time, value);
  }

  function after(time, value){
    if(!isUnsigned(time)) throwInvalidArgument('Future.after', 0, 'be a positive integer', time);
    if(arguments.length === 1) return partial1(after$time, time);
    return after$time(time, value);
  }

  function rejectAfter$time(time, reason){
    return time === Infinity ? never : new RejectAfter(time, reason);
  }

  function rejectAfter(time, reason){
    if(!isUnsigned(time)){
      throwInvalidArgument('Future.rejectAfter', 0, 'be a positive integer', time);
    }
    if(arguments.length === 1) return partial1(rejectAfter$time, time);
    return rejectAfter$time(time, reason);
  }

  function Attempt(fn){
    this._fn = fn;
  }

  Attempt.prototype = Object.create(Future.prototype);

  Attempt.prototype._interpret = function Attempt$interpret(rec, rej, res){
    var r;
    try{ r = this._fn(); }catch(e){ rej(e); return noop }
    res(r);
    return noop;
  };

  Attempt.prototype.toString = function Attempt$toString(){
    return 'Future.try(' + showf(this._fn) + ')';
  };

  function attempt(f){
    if(!isFunction(f)) throwInvalidArgument('Future.try', 0, 'be a function', f);
    return new Attempt(f);
  }

  var Cold = Cached.Cold = 0;
  var Pending = Cached.Pending = 1;
  var Crashed$1 = Cached.Crashed = 2;
  var Rejected$1 = Cached.Rejected = 3;
  var Resolved$1 = Cached.Resolved = 4;

  function Queued(rec, rej, res){
    this[Crashed$1] = rec;
    this[Rejected$1] = rej;
    this[Resolved$1] = res;
  }

  function Cached(pure){
    this._pure = pure;
    this.reset();
  }

  Cached.prototype = Object.create(Future.prototype);

  Cached.prototype.extractLeft = function Cached$extractLeft(){
    return this._state === Rejected$1 ? [this._value] : [];
  };

  Cached.prototype.extractRight = function Cached$extractRight(){
    return this._state === Resolved$1 ? [this._value] : [];
  };

  Cached.prototype._addToQueue = function Cached$addToQueue(rec, rej, res){
    var _this = this;
    if(_this._state > Pending) return noop;
    var i = _this._queue.push(new Queued(rec, rej, res)) - 1;
    _this._queued = _this._queued + 1;

    return function Cached$removeFromQueue(){
      if(_this._state > Pending) return;
      _this._queue[i] = undefined;
      _this._queued = _this._queued - 1;
      if(_this._queued === 0) _this.reset();
    };
  };

  Cached.prototype._drainQueue = function Cached$drainQueue(){
    if(this._state <= Pending) return;
    if(this._queued === 0) return;
    var queue = this._queue;
    var length = queue.length;
    var state = this._state;
    var value = this._value;

    for(var i = 0; i < length; i++){
      queue[i] && queue[i][state](value);
      queue[i] = undefined;
    }

    this._queue = undefined;
    this._queued = 0;
  };

  Cached.prototype.crash = function Cached$crash(error){
    if(this._state > Pending) return;
    this._value = error;
    this._state = Crashed$1;
    this._drainQueue();
  };

  Cached.prototype.reject = function Cached$reject(reason){
    if(this._state > Pending) return;
    this._value = reason;
    this._state = Rejected$1;
    this._drainQueue();
  };

  Cached.prototype.resolve = function Cached$resolve(value){
    if(this._state > Pending) return;
    this._value = value;
    this._state = Resolved$1;
    this._drainQueue();
  };

  Cached.prototype.run = function Cached$run(){
    var _this = this;
    if(_this._state > Cold) return;
    _this._state = Pending;
    _this._cancel = _this._pure._interpret(
      function Cached$fork$rec(x){ _this.crash(x); },
      function Cached$fork$rej(x){ _this.reject(x); },
      function Cached$fork$res(x){ _this.resolve(x); }
    );
  };

  Cached.prototype.reset = function Cached$reset(){
    if(this._state === Cold) return;
    if(this._state === Pending) this._cancel();
    this._cancel = noop;
    this._queue = [];
    this._queued = 0;
    this._value = undefined;
    this._state = Cold;
  };

  Cached.prototype._interpret = function Cached$interpret(rec, rej, res){
    var cancel = noop;

    switch(this._state){
      case Pending: cancel = this._addToQueue(rec, rej, res); break;
      case Crashed$1: rec(this._value); break;
      case Rejected$1: rej(this._value); break;
      case Resolved$1: res(this._value); break;
      default: cancel = this._addToQueue(rec, rej, res); this.run();
    }

    return cancel;
  };

  Cached.prototype.toString = function Cached$toString(){
    return 'Future.cache(' + this._pure.toString() + ')';
  };

  function cache(m){
    if(!isFuture(m)) throwInvalidFuture('Future.cache', 0, m);
    return new Cached(m);
  }

  function Encase(fn, a){
    this._fn = fn;
    this._a = a;
  }

  Encase.prototype = Object.create(Future.prototype);

  Encase.prototype._interpret = function Encase$interpret(rec, rej, res){
    var r;
    try{ r = this._fn(this._a); }catch(e){ rej(e); return noop }
    res(r);
    return noop;
  };

  Encase.prototype.toString = function Encase$toString(){
    return 'Future.encase(' + showf(this._fn) + ', ' + show(this._a) + ')';
  };

  function encase(f, x){
    if(!isFunction(f)) throwInvalidArgument('Future.encase', 0, 'be a function', f);
    if(arguments.length === 1) return partial1(encase, f);
    return new Encase(f, x);
  }

  function Encase2(fn, a, b){
    this._fn = fn;
    this._a = a;
    this._b = b;
  }

  Encase2.prototype = Object.create(Future.prototype);

  Encase2.prototype._interpret = function Encase2$interpret(rec, rej, res){
    var r;
    try{ r = this._fn(this._a, this._b); }catch(e){ rej(e); return noop }
    res(r);
    return noop;
  };

  Encase2.prototype.toString = function Encase2$toString(){
    return 'Future.encase2(' + showf(this._fn) + ', ' + show(this._a) + ', ' + show(this._b) + ')';
  };

  function encase2(f, x, y){
    if(!isFunction(f)) throwInvalidArgument('Future.encase2', 0, 'be a function', f);

    switch(arguments.length){
      case 1: return partial1(encase2, f);
      case 2: return partial2(encase2, f, x);
      default: return new Encase2(f, x, y);
    }
  }

  function Encase3(fn, a, b, c){
    this._fn = fn;
    this._a = a;
    this._b = b;
    this._c = c;
  }

  Encase3.prototype = Object.create(Future.prototype);

  Encase3.prototype._interpret = function Encase3$interpret(rec, rej, res){
    var r;
    try{ r = this._fn(this._a, this._b, this._c); }catch(e){ rej(e); return noop }
    res(r);
    return noop;
  };

  Encase3.prototype.toString = function Encase3$toString(){
    return 'Future.encase3('
         + showf(this._fn)
         + ', '
         + show(this._a)
         + ', '
         + show(this._b)
         + ', '
         + show(this._c)
         + ')';
  };

  function encase3(f, x, y, z){
    if(!isFunction(f)) throwInvalidArgument('Future.encase3', 0, 'be a function', f);

    switch(arguments.length){
      case 1: return partial1(encase3, f);
      case 2: return partial2(encase3, f, x);
      case 3: return partial3(encase3, f, x, y);
      default: return new Encase3(f, x, y, z);
    }
  }

  function EncaseN(fn, a){
    this._fn = fn;
    this._a = a;
  }

  EncaseN.prototype = Object.create(Future.prototype);

  EncaseN.prototype._interpret = function EncaseN$interpret(rec, rej, res){
    var open = false, cont = function(){ open = true; };
    try{
      this._fn(this._a, function EncaseN$done(err, val){
        cont = err ? function EncaseN3$rej(){
          open = false;
          rej(err);
        } : function EncaseN3$res(){
          open = false;
          res(val);
        };
        if(open){
          cont();
        }
      });
    }catch(e){
      rec(e);
      open = false;
      return noop;
    }
    cont();
    return function EncaseN$cancel(){ open = false; };
  };

  EncaseN.prototype.toString = function EncaseN$toString(){
    return 'Future.encaseN(' + showf(this._fn) + ', ' + show(this._a) + ')';
  };

  function encaseN(f, x){
    if(!isFunction(f)) throwInvalidArgument('Future.encaseN', 0, 'be a function', f);
    if(arguments.length === 1) return partial1(encaseN, f);
    return new EncaseN(f, x);
  }

  function EncaseN2(fn, a, b){
    this._fn = fn;
    this._a = a;
    this._b = b;
  }

  EncaseN2.prototype = Object.create(Future.prototype);

  EncaseN2.prototype._interpret = function EncaseN2$interpret(rec, rej, res){
    var open = false, cont = function(){ open = true; };
    try{
      this._fn(this._a, this._b, function EncaseN2$done(err, val){
        cont = err ? function EncaseN2$rej(){
          open = false;
          rej(err);
        } : function EncaseN2$res(){
          open = false;
          res(val);
        };
        if(open){
          cont();
        }
      });
    }catch(e){
      rec(e);
      open = false;
      return noop;
    }
    cont();
    return function EncaseN2$cancel(){ open = false; };
  };

  EncaseN2.prototype.toString = function EncaseN2$toString(){
    return 'Future.encaseN2(' + showf(this._fn) + ', ' + show(this._a) + ', ' + show(this._b) + ')';
  };

  function encaseN2(f, x, y){
    if(!isFunction(f)) throwInvalidArgument('Future.encaseN2', 0, 'be a function', f);

    switch(arguments.length){
      case 1: return partial1(encaseN2, f);
      case 2: return partial2(encaseN2, f, x);
      default: return new EncaseN2(f, x, y);
    }
  }

  function EncaseN3(fn, a, b, c){
    this._fn = fn;
    this._a = a;
    this._b = b;
    this._c = c;
  }

  EncaseN3.prototype = Object.create(Future.prototype);

  EncaseN3.prototype._interpret = function EncaseN3$interpret(rec, rej, res){
    var open = false, cont = function(){ open = true; };
    try{
      this._fn(this._a, this._b, this._c, function EncaseN3$done(err, val){
        cont = err ? function EncaseN3$rej(){
          open = false;
          rej(err);
        } : function EncaseN3$res(){
          open = false;
          res(val);
        };
        if(open){
          cont();
        }
      });
    }catch(e){
      rec(e);
      open = false;
      return noop;
    }
    cont();
    return function EncaseN3$cancel(){ open = false; };
  };

  EncaseN3.prototype.toString = function EncaseN3$toString(){
    return 'Future.encaseN3('
         + showf(this._fn)
         + ', '
         + show(this._a)
         + ', '
         + show(this._b)
         + ', '
         + show(this._c)
         + ')';
  };

  function encaseN3(f, x, y, z){
    if(!isFunction(f)) throwInvalidArgument('Future.encaseN3', 0, 'be a function', f);

    switch(arguments.length){
      case 1: return partial1(encaseN3, f);
      case 2: return partial2(encaseN3, f, x);
      case 3: return partial3(encaseN3, f, x, y);
      default: return new EncaseN3(f, x, y, z);
    }
  }

  function invalidPromise(p, f, a){
    return typeError(
      'Future.encaseP expects the function it\'s given to return a Promise/Thenable'
      + '\n  Actual: ' + (show(p)) + '\n  From calling: ' + (showf(f))
      + '\n  With: ' + (show(a))
    );
  }

  function EncaseP(fn, a){
    this._fn = fn;
    this._a = a;
  }

  EncaseP.prototype = Object.create(Future.prototype);

  EncaseP.prototype._interpret = function EncaseP$interpret(rec, rej, res){
    var open = true, fn = this._fn, a = this._a, p;
    try{
      p = fn(a);
    }catch(e){
      rec(e);
      return noop;
    }
    if(!isThenable(p)){
      rec(invalidPromise(p, fn, a));
      return noop;
    }
    p.then(function EncaseP$res(x){
      if(open){
        open = false;
        res(x);
      }
    }, function EncaseP$rej(x){
      if(open){
        open = false;
        rej(x);
      }
    });
    return function EncaseP$cancel(){ open = false; };
  };

  EncaseP.prototype.toString = function EncaseP$toString(){
    return 'Future.encaseP(' + showf(this._fn) + ', ' + show(this._a) + ')';
  };

  function encaseP(f, x){
    if(!isFunction(f)) throwInvalidArgument('Future.encaseP', 0, 'be a function', f);
    if(arguments.length === 1) return partial1(encaseP, f);
    return new EncaseP(f, x);
  }

  function invalidPromise$1(p, f, a, b){
    return typeError(
      'Future.encaseP2 expects the function it\'s given to return a Promise/Thenable'
      + '\n  Actual: ' + (show(p)) + '\n  From calling: ' + (showf(f))
      + '\n  With 1: ' + (show(a))
      + '\n  With 2: ' + (show(b))
    );
  }

  function EncaseP2(fn, a, b){
    this._fn = fn;
    this._a = a;
    this._b = b;
  }

  EncaseP2.prototype = Object.create(Future.prototype);

  EncaseP2.prototype._interpret = function EncaseP2$interpret(rec, rej, res){
    var open = true, fn = this._fn, a = this._a, b = this._b, p;
    try{
      p = fn(a, b);
    }catch(e){
      rec(e);
      return noop;
    }
    if(!isThenable(p)){
      rec(invalidPromise$1(p, fn, a, b));
      return noop;
    }
    p.then(function EncaseP2$res(x){
      if(open){
        open = false;
        res(x);
      }
    }, function EncaseP2$rej(x){
      if(open){
        open = false;
        rej(x);
      }
    });
    return function EncaseP2$cancel(){ open = false; };
  };

  EncaseP2.prototype.toString = function EncaseP2$toString(){
    return 'Future.encaseP2(' + showf(this._fn) + ', ' + show(this._a) + ', ' + show(this._b) + ')';
  };

  function encaseP2(f, x, y){
    if(!isFunction(f)) throwInvalidArgument('Future.encaseP2', 0, 'be a function', f);

    switch(arguments.length){
      case 1: return partial1(encaseP2, f);
      case 2: return partial2(encaseP2, f, x);
      default: return new EncaseP2(f, x, y);
    }
  }

  function invalidPromise$2(p, f, a, b, c){
    return typeError(
      'Future.encaseP3 expects the function it\'s given to return a Promise/Thenable'
      + '\n  Actual: ' + (show(p)) + '\n  From calling: ' + (showf(f))
      + '\n  With 1: ' + (show(a))
      + '\n  With 2: ' + (show(b))
      + '\n  With 3: ' + (show(c))
    );
  }

  function EncaseP3(fn, a, b, c){
    this._fn = fn;
    this._a = a;
    this._b = b;
    this._c = c;
  }

  EncaseP3.prototype = Object.create(Future.prototype);

  EncaseP3.prototype._interpret = function EncaseP3$interpret(rec, rej, res){
    var open = true, fn = this._fn, a = this._a, b = this._b, c = this._c, p;
    try{
      p = fn(a, b, c);
    }catch(e){
      rec(e);
      return noop;
    }
    if(!isThenable(p)){
      rec(invalidPromise$2(p, fn, a, b, c));
      return noop;
    }
    p.then(function EncaseP3$res(x){
      if(open){
        open = false;
        res(x);
      }
    }, function EncaseP3$rej(x){
      if(open){
        open = false;
        rej(x);
      }
    });
    return function EncaseP3$cancel(){ open = false; };
  };

  EncaseP3.prototype.toString = function EncaseP3$toString(){
    return 'Future.encaseP3('
         + showf(this._fn)
         + ', '
         + show(this._a)
         + ', '
         + show(this._b)
         + ', '
         + show(this._c)
         + ')';
  };

  function encaseP3(f, x, y, z){
    if(!isFunction(f)) throwInvalidArgument('Future.encaseP3', 0, 'be a function', f);

    switch(arguments.length){
      case 1: return partial1(encaseP3, f);
      case 2: return partial2(encaseP3, f, x);
      case 3: return partial3(encaseP3, f, x, y);
      default: return new EncaseP3(f, x, y, z);
    }
  }

  /*eslint consistent-return: 0, no-cond-assign: 0*/

  function invalidIteration(o){
    return typeError(
      'The iterator did not return a valid iteration from iterator.next()\n' +
      '  Actual: ' + show(o)
    );
  }

  function invalidState(x){
    return invalidFuture(
      'Future.do',
      'the iterator to produce only valid Futures',
      x,
      '\n  Tip: If you\'re using a generator, make sure you always yield a Future'
    );
  }

  function Go(generator){
    this._generator = generator;
  }

  Go.prototype = Object.create(Future.prototype);

  Go.prototype._interpret = function Go$interpret(rec, rej, res){

    var timing = Undetermined, cancel = noop, state, value, iterator;

    try{
      iterator = this._generator();
    }catch(e){
      rec(e);
      return noop;
    }

    if(!isIterator(iterator)){
      rec(invalidArgument('Future.do', 0, 'return an iterator, maybe you forgot the "*"', iterator));
      return noop;
    }

    function resolved(x){
      value = x;
      if(timing === Asynchronous) return drain();
      timing = Synchronous;
    }

    function drain(){
      //eslint-disable-next-line no-constant-condition
      while(true){
        try{
          state = iterator.next(value);
        }catch(e){
          return rec(e);
        }
        if(!isIteration(state)) return rec(invalidIteration(state));
        if(state.done) break;
        if(!isFuture(state.value)) return rec(invalidState(state.value));
        timing = Undetermined;
        cancel = state.value._interpret(rec, rej, resolved);
        if(timing === Undetermined) return timing = Asynchronous;
      }
      res(state.value);
    }

    drain();

    return function Go$cancel(){ cancel(); };

  };

  Go.prototype.toString = function Go$toString(){
    return 'Future.do(' + showf(this._generator) + ')';
  };

  function go(generator){
    if(!isFunction(generator)) throwInvalidArgument('Future.do', 0, 'be a Function', generator);
    return new Go(generator);
  }

  /* eslint no-param-reassign:0 */

  function invalidDisposal(m, f, x){
    return invalidFuture(
      'Future.hook',
      'the first function it\'s given to return a Future',
      m,
      '\n  From calling: ' + showf(f) + '\n  With: ' + show(x)
    );
  }

  function invalidConsumption(m, f, x){
    return invalidFuture(
      'Future.hook',
      'the second function it\'s given to return a Future',
      m,
      '\n  From calling: ' + showf(f) + '\n  With: ' + show(x)
    );
  }

  function Hook(acquire, dispose, consume){
    this._acquire = acquire;
    this._dispose = dispose;
    this._consume = consume;
  }

  Hook.prototype = Object.create(Future.prototype);

  Hook.prototype._interpret = function Hook$interpret(rec, rej, res){

    var _acquire = this._acquire, _dispose = this._dispose, _consume = this._consume;
    var cancel, cancelConsume = noop, resource, value, cont = noop;

    function Hook$done(){
      cont(value);
    }

    function Hook$reject(x){
      rej(x);
    }

    function Hook$consumptionException(e){
      var rec_ = rec;
      cont = noop;
      rej = noop;
      rec = noop;
      Hook$dispose();
      rec_(e);
    }

    function Hook$dispose(){
      var disposal;
      try{
        disposal = _dispose(resource);
      }catch(e){
        return rec(e);
      }
      if(!isFuture(disposal)){
        return rec(invalidDisposal(disposal, _dispose, resource));
      }
      disposal._interpret(rec, Hook$reject, Hook$done);
      cancel = Hook$cancelDisposal;
    }

    function Hook$cancelConsumption(){
      cancelConsume();
      Hook$dispose();
      Hook$cancelDisposal();
    }

    function Hook$cancelDisposal(){
      cont = noop;
      rec = noop;
      rej = noop;
    }

    function Hook$consumptionRejected(x){
      cont = rej;
      value = x;
      Hook$dispose();
    }

    function Hook$consumptionResolved(x){
      cont = res;
      value = x;
      Hook$dispose();
    }

    function Hook$consume(x){
      resource = x;
      var consumption;
      try{
        consumption = _consume(resource);
      }catch(e){
        return Hook$consumptionException(e);
      }
      if(!isFuture(consumption)){
        return Hook$consumptionException(invalidConsumption(consumption, _consume, resource));
      }
      cancel = Hook$cancelConsumption;
      cancelConsume = consumption._interpret(
        Hook$consumptionException,
        Hook$consumptionRejected,
        Hook$consumptionResolved
      );
    }

    var cancelAcquire = _acquire._interpret(rec, Hook$reject, Hook$consume);
    cancel = cancel || cancelAcquire;

    return function Hook$fork$cancel(){ cancel(); };

  };

  Hook.prototype.toString = function Hook$toString(){
    return 'Future.hook('
         + this._acquire.toString()
         + ', '
         + showf(this._dispose)
         + ', '
         + showf(this._consume)
         + ')';
  };

  function hook$acquire$cleanup(acquire, cleanup, consume){
    if(!isFunction(consume)) throwInvalidArgument('Future.hook', 2, 'be a Future', consume);
    return new Hook(acquire, cleanup, consume);
  }

  function hook$acquire(acquire, cleanup, consume){
    if(!isFunction(cleanup)) throwInvalidArgument('Future.hook', 1, 'be a function', cleanup);
    if(arguments.length === 2) return partial2(hook$acquire$cleanup, acquire, cleanup);
    return hook$acquire$cleanup(acquire, cleanup, consume);
  }

  function hook(acquire, cleanup, consume){
    if(!isFuture(acquire)) throwInvalidFuture('Future.hook', 0, acquire);
    if(arguments.length === 1) return partial1(hook$acquire, acquire);
    if(arguments.length === 2) return hook$acquire(acquire, cleanup);
    return hook$acquire(acquire, cleanup, consume);
  }

  function Node(fn){
    this._fn = fn;
  }

  Node.prototype = Object.create(Future.prototype);

  Node.prototype._interpret = function Node$interpret(rec, rej, res){
    var open = false, cont = function(){ open = true; };
    try{
      this._fn(function Node$done(err, val){
        cont = err ? function Node$rej(){
          open = false;
          rej(err);
        } : function Node$res(){
          open = false;
          res(val);
        };
        if(open){
          cont();
        }
      });
    }catch(e){
      rec(e);
      open = false;
      return noop;
    }
    cont();
    return function Node$cancel(){ open = false; };
  };

  Node.prototype.toString = function Node$toString(){
    return 'Future.node(' + showf(this._fn) + ')';
  };

  function node(f){
    if(!isFunction(f)) throwInvalidArgument('Future.node', 0, 'be a function', f);
    return new Node(f);
  }

  function Parallel(max, futures){
    this._futures = futures;
    this._length = futures.length;
    this._max = Math.min(this._length, max);
  }

  Parallel.prototype = Object.create(Future.prototype);

  Parallel.prototype._interpret = function Parallel$interpret(rec, rej, res){

    var _futures = this._futures, _length = this._length, _max = this._max;
    var cancels = new Array(_length), out = new Array(_length);
    var cursor = 0, running = 0, blocked = false;

    function Parallel$cancel(){
      cursor = _length;
      for(var n = 0; n < _length; n++) cancels[n] && cancels[n]();
    }

    function Parallel$run(idx){
      running++;
      cancels[idx] = _futures[idx]._interpret(function Parallel$rec(e){
        cancels[idx] = noop;
        Parallel$cancel();
        rec(e);
      }, function Parallel$rej(reason){
        cancels[idx] = noop;
        Parallel$cancel();
        rej(reason);
      }, function Parallel$res(value){
        cancels[idx] = noop;
        out[idx] = value;
        running--;
        if(cursor === _length && running === 0) res(out);
        else if(blocked) Parallel$drain();
      });
    }

    function Parallel$drain(){
      blocked = false;
      while(cursor < _length && running < _max) Parallel$run(cursor++);
      blocked = true;
    }

    Parallel$drain();

    return Parallel$cancel;

  };

  Parallel.prototype.toString = function Parallel$toString(){
    return 'Future.parallel(' + this._max + ', ' + show(this._futures) + ')';
  };

  var emptyArray = new Resolved([]);

  function validateNthFuture(m, i){
    if(!isFuture(m)) throwInvalidFuture(
      'Future.parallel',
      'its second argument to be an array of valid Futures. ' +
      'The value at position ' + i + ' in the array is not a Future',
      m
    );
  }

  function parallel$max(max, xs){
    if(!isArray(xs)) throwInvalidArgument('Future.parallel', 1, 'be an array', xs);
    for(var idx = 0; idx < xs.length; idx++) validateNthFuture(xs[idx], idx);
    return xs.length === 0 ? emptyArray : new Parallel(max, xs);
  }

  function parallel(max, xs){
    if(!isUnsigned(max)) throwInvalidArgument('Future.parallel', 0, 'be a positive integer', max);
    if(arguments.length === 1) return partial1(parallel$max, max);
    return parallel$max(max, xs);
  }

  function invalidPromise$3(p, f){
    return typeError(
      'Future.tryP expects the function it\'s given to return a Promise/Thenable'
      + '\n  Actual: ' + show(p) + '\n  From calling: ' + showf(f)
    );
  }

  function TryP(fn){
    this._fn = fn;
  }

  TryP.prototype = Object.create(Future.prototype);

  TryP.prototype._interpret = function TryP$interpret(rec, rej, res){
    var open = true, fn = this._fn, p;
    try{
      p = fn();
    }catch(e){
      rec(e);
      return noop;
    }
    if(!isThenable(p)){
      rec(invalidPromise$3(p, fn));
      return noop;
    }
    p.then(function TryP$res(x){
      if(open){
        open = false;
        res(x);
      }
    }, function TryP$rej(x){
      if(open){
        open = false;
        rej(x);
      }
    });
    return function TryP$cancel(){ open = false; };
  };

  TryP.prototype.toString = function TryP$toString(){
    return 'Future.tryP(' + show(this._fn) + ')';
  };

  function tryP(f){
    if(!isFunction(f)) throwInvalidArgument('Future.tryP', 0, 'be a function', f);
    return new TryP(f);
  }

  Future.of = Future[FL.of] = of;
  Future.chainRec = Future[FL.chainRec] = chainRec;
  Future.reject = reject;
  Future.ap = ap;
  Future.map = map;
  Future.bimap = bimap;
  Future.chain = chain;

  var Par = concurrify(Future, never, race, function parallelAp(a, b){ return b._parallelAp(a) });
  Par.of = Par[FL.of];
  Par.zero = Par[FL.zero];
  Par.map = map;
  Par.ap = ap;
  Par.alt = alt;

  function isParallel(x){
    return x instanceof Par || type(x) === Par['@@type'];
  }

  function seq(par){
    if(!isParallel(par)) throwInvalidArgument('Future.seq', 0, 'to be a Par', par);
    return par.sequential;
  }

  var Fluture = /*#__PURE__*/Object.freeze({
    Future: Future,
    default: Future,
    Par: Par,
    isParallel: isParallel,
    seq: seq,
    isFuture: isFuture,
    reject: reject,
    of: of,
    never: never,
    isNever: isNever,
    after: after,
    rejectAfter: rejectAfter,
    attempt: attempt,
    try: attempt,
    cache: cache,
    encase: encase,
    encase2: encase2,
    encase3: encase3,
    encaseN: encaseN,
    encaseN2: encaseN2,
    encaseN3: encaseN3,
    encaseP: encaseP,
    encaseP2: encaseP2,
    encaseP3: encaseP3,
    go: go,
    do: go,
    hook: hook,
    node: node,
    parallel: parallel,
    tryP: tryP,
    ap: ap,
    alt: alt,
    map: map,
    bimap: bimap,
    chain: chain,
    mapRej: mapRej,
    chainRej: chainRej,
    lastly: lastly,
    finally: lastly,
    and: and,
    both: both,
    or: or,
    race: race,
    swap: swap,
    fold: fold,
    done: done,
    fork: fork,
    forkCatch: forkCatch,
    promise: promise,
    value: value,
    extractLeft: extractLeft,
    extractRight: extractRight
  });

  var index_cjs = Object.assign(Future, Fluture);

  return index_cjs;

})));
