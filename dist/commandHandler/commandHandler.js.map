{"version":3,"sources":["../../src/commandHandler/commandHandler.js"],"names":["searchGiphy","keyword","rej","res","requester","Giphy","search","then","catch","appendAddButton","getOriginalUrl","a","head","makeResponseMessageForDooray","wrapWithArray","makeKeywordText","concat","dooray","body"],"mappings":";;;;;;;AAAA;;;;AACA;;AAYA;;;;AACA;;AAIA;;;;AAEO,IAAMA,oCAAc,gBACvB,+CADuB,EAEvB,UAACC,OAAD,EAAa;AACT,WAAO,uBAAO,UAACC,GAAD,EAAMC,GAAN,EAAc;AACxBC,4BAAUC,KAAV,CAAgBC,MAAhB,CAAuBL,OAAvB,EAAgCM,IAAhC,CAAqC,iBAAK,iBAAK,MAAL,CAAL,EAAmBJ,GAAnB,CAArC,EAA8DK,KAA9D,CAAoEN,GAApE;AACH,KAFM,CAAP;AAGH,CANsB,CAApB;;AASP;AACA;AACA;AACA;AACA;;AAEA,IAAMO,kBAAkB,mBAAO;AAC3B,eAAW,CAAC;AACR,gBAAQ,MADA;AAER,gBAAQ,UAFA;AAGR,gBAAQ,QAHA;AAIR,iBAAS;AAJD,KAAD;AADgB,CAAP,CAAxB;;AASO,IAAMC,0CAAiB,SAAjBA,cAAiB,CAACC,CAAD,EAAO;AACjC,WAAO,iBACH,iBAAK,MAAL,CADG,EAEHC,WAFG,EAGH,iBAAK,CAAC,QAAD,EAAW,UAAX,EAAuB,KAAvB,CAAL,CAHG,EAILD,CAJK,CAAP;AAKH,CANM;;AAQP,IAAME,+BAA+B,iBACjCH,cADiC,EAEjC,4BAAe,UAAf,CAFiC,EAGjCI,qBAHiC,EAIjCL,eAJiC,EAKjC,4BAAe,aAAf,CALiC,CAArC;;AAQA,IAAMM,kBAAkB,iBACpB,iBAAK,MAAL,CADoB,EAEpB,mBAAO,IAAP,CAFoB,EAGpB,iBAAKC,aAAL,EAAa,cAAb,CAHoB,EAIpB,4BAAe,MAAf,CAJoB,CAAxB;;AAOA;AACA,IAAMV,SAAS,iBACX,iBAAK,MAAL,CADW,EAEXN,WAFW,CAAf;;AAKA,IAAMiB,SAAS,SAATA,MAAS,CAACC,IAAD,EAAU;AACrB,WAAO,iBACHZ,MADG,EAEH,gBAAIO,4BAAJ,CAFG,EAGH,gBAAI,kBAAME,gBAAgBG,IAAhB,CAAN,CAAJ,CAHG,EAILA,IAJK,CAAP;AAKH,CAND;;kBAQe;AACXD;AADW,C","file":"commandHandler.js","sourcesContent":["import Future from 'fluture';\nimport {\n    concat,\n    flip,\n    append,\n    head,\n    map,\n    merge,\n    path,\n    pipe,\n    prop,\n    tap\n} from 'ramda';\nimport requester from '../requester';\nimport {\n    wrapWithArray,\n    wrapWithObject\n} from '../utils/fnUtil';\nimport {def} from '../types';\n\nexport const searchGiphy = def(\n    'searchGiphy :: String -> Future Object Object',\n    (keyword) => {\n        return Future((rej, res) => {\n            requester.Giphy.search(keyword).then(pipe(prop('data'), res)).catch(rej);\n        });\n    }\n)\n\n// export const searchGiphy = (keyword) => {\n//     return Future((rej, res) => {\n//         requester.Giphy.search(keyword).then(pipe(prop('data'), res)).catch(rej);\n//     });\n// }\n\nconst appendAddButton = append({\n    \"actions\": [{\n        \"name\": \"send\",\n        \"text\": \"보내기(미구현)\",\n        \"type\": \"button\",\n        \"value\": \"send\"\n    }]\n})\n\nexport const getOriginalUrl = (a) => {\n    return pipe(\n        prop('data'),\n        head,\n        path(['images', 'original', 'url'])\n    )(a);\n}\n\nconst makeResponseMessageForDooray = pipe(\n    getOriginalUrl,\n    wrapWithObject('imageUrl'),\n    wrapWithArray,\n    appendAddButton,\n    wrapWithObject('attachments')\n)\n\nconst makeKeywordText = pipe(\n    prop('text'),\n    concat('\\''),\n    flip(concat)('\\'에 대한 검색 결과'),\n    wrapWithObject('text')\n)\n\n// search :: Obj -> Future [Obj]\nconst search = pipe(\n    prop('text'),\n    searchGiphy\n);\n\nconst dooray = (body) => {\n    return pipe(\n        search,\n        map(makeResponseMessageForDooray),\n        map(merge(makeKeywordText(body)))\n    )(body);\n}\n\nexport default {\n    dooray\n};"]}