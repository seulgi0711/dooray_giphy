{"version":3,"sources":["../../src/reqHandler/reqHandler.js"],"names":["removeActions","convertThumbToImageUrl","thumbUrl","pickAttachmentForSend","targetImageIndex","attachments","head","identity","createSendResult","reqBody","createInChannelResponse","createReplaceResponse","Future","of","search","requester","Giphy","searchWithOffset","getSearchKeyword","extractOffset","createOriginImageAttachment","reqHandler","isSendButton","isSearchButton","searchOneImage","T","text"],"mappings":";;;;;;;AAAA;;;;AACA;;AACA;;AACA;;AACA;;;;AACA;;AACA;;AACA;;AACA;;AACA;;;;AAEO,IAAMA,wCAAgB,gBACzB,mCADyB,EAEzB,mBAAO,SAAP,CAFyB,CAAtB;;AAKA,IAAMC,0DAAyB,gBAClC,4CADkC,EAElC,oBAAO,EAACC,UAAU,UAAX,EAAP,CAFkC,CAA/B;;AAKP;AACO,IAAMC,wDAAwB,gBACjC,yDADiC,EAEjC,UAACC,gBAAD,EAAmBC,WAAnB,EAAmC;AAC/B,WAAO,iBACH,kBAAMD,gBAAN,EAAwBA,mBAAmB,CAA3C,CADG,EAEH,qBAAS,mBAAO,CAAP,CAAT,EAAoB,CAAC,iBAAKE,WAAL,EAAWN,aAAX,EAA0BC,sBAA1B,CAAD,EAAoDM,eAApD,CAApB,CAFG,EAGLF,WAHK,CAAP;AAIH,CAPgC,CAA9B;;AAUA,IAAMG,8CAAmB,gBAC5B,qDAD4B,EAE5B,UAACC,OAAD,EAAa;AACT,qBACI,iBAAK,iBAAL,CADJ,EAEI,iBAAK,CAAC,MAAD,EAAS,aAAT,CAAL,CAFJ,EAGI,mBAAO,EAAEJ,aAAaF,sBAAsB,sBAAS,gCAAeM,OAAf,CAAT,CAAtB,CAAf,EAAP,CAHJ,EAII,oBAAO,mFAAP;AACA;AACA;AACA;AACA;AARJ,MASEA,OATF;;AAWA,WAAO,iBACH,iBAAK,iBAAL,CADG,EAEH,iBAAK,CAAC,MAAD,EAAS,aAAT,CAAL,CAFG,EAGH,mBAAO,EAAEJ,aAAaF,sBAAsB,sBAAS,gCAAeM,OAAf,CAAT,CAAtB,CAAf,EAAP,CAHG,EAIH,oBAAO,aAAP,CAJG,EAKHC,qCALG,EAMHC,mCANG,EAOHC,kBAAOC,EAPJ,EAQLJ,OARK,CAAP;AASH,CAvB2B,CAAzB;;AA0BA,IAAMK,0BAAS,gBAClB,0CADkB,EAElB,iBACI,qBAASC,oBAAUC,KAAV,CAAgBC,gBAAzB,EAA2C,CAACC,6BAAD,EAAmBC,0BAAnB,CAA3C,CADJ,EAEI,gBAAIC,yCAAJ,CAFJ,CAFkB,CAAf;;AAQP;AACA,IAAMC,aAAa,gBACf,8CADe,EAEf,iBACI,iBAAK,MAAL,CADJ,EAEI,iBAAK,CACD,CAACC,wBAAD,EAAed,gBAAf,CADC,EAED,CAACe,0BAAD,EAAiBC,6BAAjB,CAFC,EAGD,CAACC,QAAD,EAAIb,kBAAOC,EAAP,CAAU,EAAEa,MAAM,MAAR,EAAV,CAAJ,CAHC,CAAL,CAFJ,CAFe,CAAnB;;kBAYeL,U","file":"reqHandler.js","sourcesContent":["import Future from \"fluture\";\nimport { parseInt } from \"lodash\";\nimport { cond, converge, dissoc, evolve, head, identity, map, pick, pipe, prop, slice, T, update } from \"ramda\";\nimport { searchOneImage, searchOneImageInReq } from '../giphySearcher';\nimport requester from \"../requester/requester\";\nimport { def } from \"../types/types\";\nimport { getActionValue, isSearchButton, isSendButton } from \"../utils/actionUtil\";\nimport { logTap, rename } from '../utils/fnUtil';\nimport { extractOffset, getSearchKeyword } from \"../utils/requestUtil\";\nimport { createInChannelResponse, createOriginImageAttachment, createReplaceResponse } from \"../utils/responseUtil\";\n\nexport const removeActions = def(\n    'removeActions :: Object -> Object',\n    dissoc('actions')\n);\n\nexport const convertThumbToImageUrl = def(\n    'convertThumbToImageUrl :: Object -> Object',\n    rename({thumbUrl: 'imageUrl'})\n)\n\n// prettier-ignore\nexport const pickAttachmentForSend = def(\n    'pickAttachmentForSend :: Number -> [Object] -> [Object]',\n    (targetImageIndex, attachments) => {\n        return pipe(\n            slice(targetImageIndex, targetImageIndex + 1),\n            converge(update(0), [pipe(head, removeActions, convertThumbToImageUrl), identity])\n        )(attachments);\n    }\n);\n\nexport const createSendResult = def(\n    \"createSendResult :: ReqBody -> Future Object Object\",\n    (reqBody) => {\n        pipe(\n            prop(\"originalMessage\"),\n            pick([\"text\", \"attachments\"]),\n            evolve({ attachments: pickAttachmentForSend(parseInt(getActionValue(reqBody))) }),\n            logTap('evolve({ attachments: pickAttachmentForSend(parseInt(getActionValue(reqBody))) })')\n            // logTap('attachments'),\n            // createInChannelResponse,\n            // createReplaceResponse,\n            // Future.of\n        )(reqBody)\n\n        return pipe(\n            prop(\"originalMessage\"),\n            pick([\"text\", \"attachments\"]),\n            evolve({ attachments: pickAttachmentForSend(parseInt(getActionValue(reqBody))) }),\n            logTap('attachments'),\n            createInChannelResponse,\n            createReplaceResponse,\n            Future.of\n        )(reqBody);\n    }\n);\n\nexport const search = def(\n    \"search :: Object -> Future Object Object\",\n    pipe(\n        converge(requester.Giphy.searchWithOffset, [getSearchKeyword, extractOffset]),\n        map(createOriginImageAttachment)\n    )\n);\n\n// prettier-ignore\nconst reqHandler = def(\n    \"reqHandler :: Object -> Future Object Object\",\n    pipe(\n        prop(\"body\"),\n        cond([\n            [isSendButton, createSendResult],\n            [isSearchButton, searchOneImage],\n            [T, Future.of({ text: 'nono' })]\n        ]),\n    )\n);\n\nexport default reqHandler;\n"]}